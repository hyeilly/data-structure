# 수식 트리(Expression Tree)의 구현

- 수식트리를 메모리에 수식을 표기하는 표기법의 일종으로 볼 수 있음

## 수식 트리의 이해

- 중위 표기법의 수식을 수식 트리로 변환하는 프로그램의 작성이 목적

```
int main(void)
{
  int result = 0;
  result = 7 + 4 * 2 - 1;
}
```

- 중위 표기법의 수식은 사람이 인식하기 좋은 수식. 컴퓨터의 인식에는 어려움이 있음
- 그래서 컴파일러는 중위 표기법의 수식을 '수식 트리'로 재구성
- 수식 트리는 해석이 쉬움. 연산의 과정에서 우선순위를 고려하지 않아도 됨

## 수식트리의 계산 과정

- 두 개의 자식 노드가 피연산자라는 단순하지만 전부인 하나의 특성을 근거로 연산 매우 쉽게 진행

## 수식트리를 만드는 절차

- 중위 표기법의 수식 -> 후위 표기법의 수식 -> 수식 트리

- 중위 표기법의 수식을 바로 수식 트리로 표현하는 것은 쉽지 않음
- 하지만 일단 후위 표기법의 수식으로 변경한 다음에 수식 트리로 표현하는 것은 어렵지 않음

### 수식 트리의 구현과 관련된 헤더파일

- 구조체의 정의 가장 중요함.
  `#include "BinaryTree2.h"`
- `BTreeNode * MakeExpTree(char exp[]);` // 수식 트리 구성
  - 후위 표기법의 수식을 인자로 받아서 수식 트리를 구성하고 루트 노드의 주소값 반환
- `int EvaluateExpTree(BTreeNode * bt);` // 수식 트리 계산
  - MakeExpTree가 구성한 수식 트리의 수식을 계산하여 그 결과를 반환
- `void ShowPrefixTypeExp(BTreeNode * bt); ` // 전위 표기법 기반 출력
- `void ShowInfixTypeExp(BTreeNode * bt); ` // 중위 표기법 기반 출력
- `void ShowPostfixTypeExp(BTreeNode * bt); ` // 후위 표기법 기반 출력
  - 전위, 중위, 후위 순회하여 출력 시 각각 전위, 중위, 후위 표기법의 수식이 출력

## 수식 트리의 구성 방법: 그림상 이해

- 후위 표기법의 수식에서 먼저 등장하는 피연산자와 연산자를 이용해서 **트리의 하단**부터 구성해 나가고 이어서 점진적으로 윗부분을 구성해 나감
- 서브트리를 어떻게 스택에 넣을 수 있을지
  - 이진트리의 주소값 : 루트 노드의 주소값 만으로 이진트리 주소값으로 간주
  - 무조건 서브트리가 만들어지면 스택에서 서브트리를 꺼내서 또 다른 서브트리 만들었다 할지라도 스택에 넣기

### 수식 트리의 구성 방법

ex) 1 2 + 7 \*

1. stack = [1] => 2 + 7 \* // 피연산자는 무조건 스택으로
2. stack = [1, 2] => + 7 \*
3. stack = [] => 7 \* // 연산자를 만나면 스택에서 피연산자 두 개 꺼내어 트리 구성
4. stack = [1 + 2] => 7 \* // 형성된 트리는 다시 스택으로 들어감
5. stack = [1 + 2, 7] => \*
6. 곱셈까지 들어가서 구성하면 최종 결과는 스택에서
