## 충돌 문제의 해결책

### 선형 조사법(Linear Probing)

- ex) 1차 저장
  - 해시함수 key % 7
    - 값이 이미 저장된 인덱스에 다른 또 저장하려면 충돌 발생
    - `f(k) + 1` => `f(k) + 2` => `f(k) + 3` ...
- 선형 조사법은 단순하지만, 충돌의 횟수가 증가함에 따라서 클러스터 현상(특정 영역에 데이터가 몰리는 현상)이 발생한다는 단점

### 이차 조사법과 슬롯의 상태 DELETED

- `f(k) + 1^2` => `f(k) + 2^2` => `f(k) + 3^2` ...
- 선형 조사법 보다 멀리서 빈자리를 찾음(점점 찾는 위치가 멀어짐)
- DELETED 상태로 별도 표시해 두어야 동일한 해시값의 데이터 저장을 의심 가능
  - 데이터 저장됐다가 삭제된 상태가 필요한 이유

### 이중 해시 : 이해

- 해시 값이 같으면, 충돌 발생 시 빈 슬롯을 찾기 위한 접근 위치가 늘 동일하다는 문제 해결 방법
- 총 두 개의 해시함수를 활용하는 방법
- 1차 해시 함수 `h1(k) = k % 15` 배열의 길이가 15인 경우의 예
- 2차 해시 함수 `h2(k) = 1 + (k % c)` 15보다 작은 소수로 c를 결정
- => c의 결정 예시
  - 1차 해시 함수 `h1(k) = k % 15`
  - 2차 해시 함수 `h2(k) = 1 + (k % 7)`
    - 1 더하는 이유 : 2차 해시 값 0되는 것 막기 위해
    - c 를 15보다 작은 값으로 하는 이유 : 배열의 길이 15이므로
    - c를 소수로 결정하는 이유 : 클러스터 현상을 낮춘다는 통계 근거로

### 이중 해시 : 적용

- 1차 해시 함수 `h1(k) = k % 15`
- 2차 해시 함수 `h2(k) = 1 + (k % 7)`

- 실제로는 2차 해시 값을 근거로 빈 자리를 찾기 때문에 1차 해시값이 같아도 빈 자리를 찾는 위치는 달라짐
- `h1(3) = 3 % 15 = 3` 1차 저장
- `h1(18) = 18 % 15 = 3` 2차 충돌 => `h2(18) = 1 + 18 % 7 = 5` 18에 대한 2차 해시값
- `h1(33) = 33 % 15 = 3` 3차 충돌 => `h2(33) = 1 + 33 % 7 = 6` 33에 대한 2차 해시값
