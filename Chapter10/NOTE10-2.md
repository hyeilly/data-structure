## 복잡하지만 효율적인 정렬 알고리즘

### 힙 정렬

- 우선순위의 기준을 판단하는 함수를 힙에 등록
- 우선순위가 가장 높은 데이터가 루트 노드에 저장됨

- 힙의 특성을 활용하여 힙에 정렬할 대상을 모두 넣었다가 다시 꺼내어 정렬을 진행

#### 힙 정렬 : 성능 평가

- 하나의 데이터를 힙에 넣고 빼는 경우에 대한 시간 복잡도
  - 힙의 데이터 저장 시간 복잡도 O(log2n)
  - 힙의 데이터 삭제 시간 복잡도 O(log2n)
- 하나로 묶으면 `O(2log2n)` 앞의 2는 빅-오에서 무시하여 `O(log2n)`
  - 비교 연산으로 봤을 때 n이 커질때 n^2 / nlog2n ...를 고려해야함

### 병합 정렬

- 병합 정렬 알고리즘 역시 DAC를 기반으로 설계된 알고리즘

- 1단계 분할 : 해결이 용이한 단계까지 문제를 분할해 나감
- 2단계 정복 : 해결이 용이한 수준까지 분할된 문제를 해결
- 3단계 결합 : 분할해서 해결한 결과를 결합하여 마무리

#### 병합 정렬 : DAC 관점에서의 이해

- 1단계 분할 : 정렬하기 좋은 상태로 분할을 진행해 나감
- 2단계 정렬 : 정렬하기 좋은 상태에서 정렬을 하고
- 3단계 결합 : 정렬이 완료된 조각들을 결합하여 정렬을 끝냄

- 분할의 과정이 재귀적. 별도의 정렬을 진행하지 않아도 될 수준까지 분할을 진행
  - 분할보다 신경 써야 하는 것이 병합과정
- ex)
- 8 2 3 7 1 5 4 6
- 분할의 과정
  - 8 2 3 7 / 1 5 4 6
  - 8 2 / 3 7 / 1 5 / 4 6
  - 8 / 2 / 3 / 7 / 1 / 5 / 4 / 6
- 병합의 과정
  - 2 8 / 3 7 / 1 5 / 4 6
  - 2 3 7 8 / 1 4 5 6
  - 1 / 2 / 3 / 4 / 5 / 6 / 7 / 8

1. 분할의 과정이 재귀적 => 병합을 진행
2. 별도 정렬을 진행하지 않아도 될 수준까지 분할을 진행
3. 분할보다 신경 써야하는 것이 병합 과정. => 병합 정렬

#### 병합 정렬 : 성능 평가

- 데이터의 비교 및 데이터의 이동은 `MergeTwoArea` 함수를 중심으로 진행
- 병합 정렬의 성능은 `MergeTwoArea` 함수를 기준으로 계산
- 병합의 단계 - 데이터의 수에 따른 병합의 과정 -> log2n으로 결정이 됨
- `y = log2x`

- 정렬의 대상인 데이터의 수가 n개 일 때, 각 병합의 단계마다 최대 n번의 비교연산이 진행됨
- 따라서 데이터 수에 대한 비교 연산의 횟수는 nlog2n
- 따라서 비교 연산에 대한 빅-오는 O(nlog2n)

#### 병합 정렬 : 성능 평가(이동)

- 임시 배열에 데이터를 병합하는 과정에서 한 번
- 임시 배열에 저장된 데이터 전부를 원위치로 옮기는 과정에서 한 번
- 2nlog2n => O(nlog2n)

### 퀵 정렬

#### 퀵 정렬

##### 1단계: 초기화

- 퀵 정렬을 위해서는 5개의 변수 left, right, pivot, low, high를 선언
- left : 정렬대상의 가장 왼쪽 지점을 가리키는 이름
- right : 정렬대상의 가장 오른쪽 지점을 가리키는 이름
- pivot : 피벗이라 발음. 중심점, 중심축의 의미를 담고 있음
- low : 피벗을 제외한 가장 왼쪽에 위치한 지점을 가리키는 이름
- high : 피벗을 제외한 가장 오른쪽에 위치한 지점을 가리키는 이름
- 가장 왼쪽에 위치한 데이터를 피벗으로 결정하기로 함

##### 2단계: low와 high 의 이동

- low의 오른쪽 방향 이동 : 피벗보다 큰 값을 만날 때까지
  - 피벗보다 정렬의 우선순위가 낮은 데이터를 만날 때까지
- high의 왼쪽 방향 이동 : 피벗보다 작은 값을 만날 때까지
  - 피벗보다 정렬의 우선순위가 높은 데이터를 만날 때까지

##### 3단계: low와 high 의 교환

1. low와 high의 데이터 교환
2. 교환 후 이동을 계속, 그리고 또 교환
3. 이동을 계속, high와 low가 역전 될 때까지

##### 4단계: 피벗의 이동

1. high와 low가 역전되면, 피벗과 high의 데이터 교환

- 여기까지가 1회전 완료
- 피봇의 앞 영역은 우선순위가 더 높음. 앞 뒤가 섞일 일은 없음

2. 두 개의 영역으로 나누어 반복 실행

- left > right 관계에 놓일 때까지 반복 => 더이상 쪼갤 수 없음
