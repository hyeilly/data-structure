## 복잡하지만 효율적인 정렬 알고리즘

### 힙 정렬

- 우선순위의 기준을 판단하는 함수를 힙에 등록
- 우선순위가 가장 높은 데이터가 루트 노드에 저장됨

- 힙의 특성을 활용하여 힙에 정렬할 대상을 모두 넣었다가 다시 꺼내어 정렬을 진행

#### 힙 정렬 : 성능 평가

- 하나의 데이터를 힙에 넣고 빼는 경우에 대한 시간 복잡도
  - 힙의 데이터 저장 시간 복잡도 O(log2n)
  - 힙의 데이터 삭제 시간 복잡도 O(log2n)
- 하나로 묶으면 `O(2log2n)` 앞의 2는 빅-오에서 무시하여 `O(log2n)`
  - 비교 연산으로 봤을 때 n이 커질때 n^2 / nlog2n ...를 고려해야함

### 병합 정렬

- 병합 정렬 알고리즘 역시 DAC를 기반으로 설계된 알고리즘

- 1단계 분할 : 해결이 용이한 단계까지 문제를 분할해 나감
- 2단계 정복 : 해결이 용이한 수준까지 분할된 문제를 해결
- 3단계 결합 : 분할해서 해결한 결과를 결합하여 마무리

#### 병합 정렬 : DAC 관점에서의 이해

- 1단계 분할 : 정렬하기 좋은 상태로 분할을 진행해 나감
- 2단계 정렬 : 정렬하기 좋은 상태에서 정렬을 하고
- 3단계 결합 : 정렬이 완료된 조각들을 결합하여 정렬을 끝냄

- 분할의 과정이 재귀적. 별도의 정렬을 진행하지 않아도 될 수준까지 분할을 진행
  - 분할보다 신경 써야 하는 것이 병합과정
- ex)
- 8 2 3 7 1 5 4 6
- 분할의 과정
  - 8 2 3 7 / 1 5 4 6
  - 8 2 / 3 7 / 1 5 / 4 6
  - 8 / 2 / 3 / 7 / 1 / 5 / 4 / 6
- 병합의 과정
  - 2 8 / 3 7 / 1 5 / 4 6
  - 2 3 7 8 / 1 4 5 6
  - 1 / 2 / 3 / 4 / 5 / 6 / 7 / 8

1. 분할의 과정이 재귀적 => 병합을 진행
2. 별도 정렬을 진행하지 않아도 될 수준까지 분할을 진행
3. 분할보다 신경 써야하는 것이 병합 과정. => 병합 정렬

#### 병합 정렬 : 성능 평가

- 데이터의 비교 및 데이터의 이동은 `MergeTwoArea` 함수를 중심으로 진행
- 병합 정렬의 성능은 `MergeTwoArea` 함수를 기준으로 계산
- 병합의 단계 - 데이터의 수에 따른 병합의 과정 -> log2n으로 결정이 됨
- `y = log2x`

- 정렬의 대상인 데이터의 수가 n개 일 때, 각 병합의 단계마다 최대 n번의 비교연산이 진행됨
- 따라서 데이터 수에 대한 비교 연산의 횟수는 nlog2n
- 따라서 비교 연산에 대한 빅-오는 O(nlog2n)

#### 병합 정렬 : 성능 평가(이동)

- 임시 배열에 데이터를 병합하는 과정에서 한 번
- 임시 배열에 저장된 데이터 전부를 원위치로 옮기기
