## 복잡하지만 효율적인 정렬 알고리즘

### 힙 정렬

- 우선순위의 기준을 판단하는 함수를 힙에 등록
- 우선순위가 가장 높은 데이터가 루트 노드에 저장됨

- 힙의 특성을 활용하여 힙에 정렬할 대상을 모두 넣었다가 다시 꺼내어 정렬을 진행

#### 힙 정렬 : 성능 평가

- 하나의 데이터를 힙에 넣고 빼는 경우에 대한 시간 복잡도
  - 힙의 데이터 저장 시간 복잡도 O(log2n)
  - 힙의 데이터 삭제 시간 복잡도 O(log2n)
- 하나로 묶으면 `O(2log2n)` 앞의 2는 빅-오에서 무시하여 `O(log2n)`
  - 비교 연산으로 봤을 때 n이 커질때 n^2 / nlog2n ...를 고려해야함

### 병합 정렬

- 병합 정렬 알고리즘 역시 DAC를 기반으로 설계된 알고리즘

- 1단계 분할 : 해결이 용이한 단계까지 문제를 분할해 나감
- 2단계 정복 : 해결이 용이한 수준까지 분할된 문제를 해결
- 3단계 결합 : 분할해서 해결한 결과를 결합하여 마무리

#### 병합 정렬 : DAC 관점에서의 이해

- 1단계 분할 : 정렬하기 좋은 상태로 분할을 진행해 나감
- 2단계 정렬 : 정렬하기 좋은 상태에서 정렬을 하고
- 3단계 결합 : 정렬이 완료된 조각들을 결합하여 정렬을 끝냄

- 분할의 과정이 재귀적. 별도의 정렬을 진행하지 않아도 될 수준까지 분할을 진행
  - 분할보다 신경 써야 하는 것이 병합과정
- ex)
- 8 2 3 7 1 5 4 6
- 분할의 과정
  - 8 2 3 7 / 1 5 4 6
  - 8 2 / 3 7 / 1 5 / 4 6
  - 8 / 2 / 3 / 7 / 1 / 5 / 4 / 6
- 병합의 과정
  - 2 8 / 3 7 / 1 5 / 4 6
  - 2 3 7 8 / 1 4 5 6
  - 1 / 2 / 3 / 4 / 5 / 6 / 7 / 8

1. 분할의 과정이 재귀적 => 병합을 진행
2. 별도 정렬을 진행하지 않아도 될 수준까지 분할을 진행
3. 분할보다 신경 써야하는 것이 병합 과정. => 병합 정렬

#### 병합 정렬 : 성능 평가

- 데이터의 비교 및 데이터의 이동은 `MergeTwoArea` 함수를 중심으로 진행
- 병합 정렬의 성능은 `MergeTwoArea` 함수를 기준으로 계산
- 병합의 단계 - 데이터의 수에 따른 병합의 과정 -> log2n으로 결정이 됨
- `y = log2x`

- 정렬의 대상인 데이터의 수가 n개 일 때, 각 병합의 단계마다 최대 n번의 비교연산이 진행됨
- 따라서 데이터 수에 대한 비교 연산의 횟수는 nlog2n
- 따라서 비교 연산에 대한 빅-오는 O(nlog2n)

#### 병합 정렬 : 성능 평가(이동)

- 임시 배열에 데이터를 병합하는 과정에서 한 번
- 임시 배열에 저장된 데이터 전부를 원위치로 옮기는 과정에서 한 번
- 2nlog2n => O(nlog2n)

### 퀵 정렬

#### 퀵 정렬

##### 1단계: 초기화

- 퀵 정렬을 위해서는 5개의 변수 left, right, pivot, low, high를 선언
- left : 정렬대상의 가장 왼쪽 지점을 가리키는 이름
- right : 정렬대상의 가장 오른쪽 지점을 가리키는 이름
- pivot : 피벗이라 발음. 중심점, 중심축의 의미를 담고 있음
- low : 피벗을 제외한 가장 왼쪽에 위치한 지점을 가리키는 이름
- high : 피벗을 제외한 가장 오른쪽에 위치한 지점을 가리키는 이름
- 가장 왼쪽에 위치한 데이터를 피벗으로 결정하기로 함

##### 2단계: low와 high 의 이동

- low의 오른쪽 방향 이동 : 피벗보다 큰 값을 만날 때까지
  - 피벗보다 정렬의 우선순위가 낮은 데이터를 만날 때까지
- high의 왼쪽 방향 이동 : 피벗보다 작은 값을 만날 때까지
  - 피벗보다 정렬의 우선순위가 높은 데이터를 만날 때까지

##### 3단계: low와 high 의 교환

1. low와 high의 데이터 교환
2. 교환 후 이동을 계속, 그리고 또 교환
3. 이동을 계속, high와 low가 역전 될 때까지

##### 4단계: 피벗의 이동

1. high와 low가 역전되면, 피벗과 high의 데이터 교환

- 여기까지가 1회전 완료
- 피봇의 앞 영역은 우선순위가 더 높음. 앞 뒤가 섞일 일은 없음

2. 두 개의 영역으로 나누어 반복 실행

- left > right 관계에 놓일 때까지 반복 => 더이상 쪼갤 수 없음

#### 퀵 정렬 구현 - 피벗 선택에 대한 논의

- pivot 1 2 3 4 5 6 7 8 9
  - 정렬이 되어 있고, 피벗이 정렬 대상의 한 쪽 끝에 치우치는 경우 최악의 경우를 보임
- pivot 5 9 6 7 3 2 8 1 4
  - 데이터가 불규칙적으로 나열되어 있고 피벗이 중간에 해당하는 값에 가깝게 선택 될 수록 최상의 경우
- 5 1 3 7 9 2 4 6 8
  - 정렬과정에서 선택되는 피벗의 수가 적을수록 최상의 경우에 해당됨
- 피벗이 **가급적** 중간에 해당하는 값이 선택되어야 좋은 성능을 보임
- 무조건 중간에 있는 값을 선택할 수 있는 방법
  - 방법1) 5 3 4 중에 중간에 있는 값 선택 => 4 선택
  - 방법2) 앞에있는 데이터 3개 선택 5 9 6 => 이 중 중간값 선택 => 6 선택

#### 퀵 정렬 : 성능평가 (최선의 경우 - Best Case)

- 모든 데이터가 피벗과의 데이터 비교를 진행. 따라서 **n번의 비교 연산**이 진행
- n개의 데이터가 몇 번 2로 나누었을 때 1개가 되는지
- `k = log2n` - 최선의 경우 빅-오 O(nlog2n)
- example
  - 31개의 데이터는 15개씩 둘로 나뉘어 총 2조각이 됨 - 1차 나뉨
  - 이어서 각각 7개씩 둘로 나뉘어 총 4조각이 됨 - 2차 나뉨
  - 이어서 각각 3개씩 둘로 나뉘어 총 8조각이 됨 - 3차 나뉨
  - 이어서 각각 1개씩 둘로 나뉘어 총 16조각이 됨 - 4차 나뉨

#### 퀵 정렬 : 성능평가 (최악의 경우 - Worst Case)

- 맨 왼쪽에 있는 데이터를 가지고 pivot으로 선택
- pivot 1 2 3 4 5 6 7 8 9
  - 둘로 나뉘는 횟수가 약 n!
  - 매 단계별 비교 연산의 횟수 약 n!
  - `O(n^2)`
- 중간에 가까운 값으로 빅-오를 선택하려는 노력을 조금만 하더라도 퀵 정렬은 최악의 경우를 만들지 않음
- 퀵 정렬의 성능은 최상의 경우를 근거로 이야기함

- 퀵 정렬은 O(nlog2n)의 성능을 보이는 정렬 알고리즘 중에서 평균적으로 가장 좋은 성능을 보임
- 다른 알고리즘에 비해서 데이터의 이동이 적고 별도의 메모리 공간을 요구하지 않음

### 기수 정렬

- 정렬순서의 앞서고 뒤섬을 비교하지 않음
- 정렬 알고리즘의 한계로 알려진 O(nlog2n)을 뛰어 넘을 수 있음
- 적용할 수 있는 대상이 매우 제한적. **길이가 동일한 데이터**들의 정렬에 용이

- 기수 정렬이 가능한 예시
  - 배열에 저장된 1, 7, 9, 5, 2, 6을 오름차순으로 정렬하라
  - 영단어 red, why, zoo, box를 사전편찬 순서대로 정렬하라
- 기수 정렬이 불가능한 예시
  - 기수 정렬을 하려면 가공/연산이 필요함
  - 배열에 저장된 21, -9, 125, 8, -136, 45를 오름차순으로 정렬하라
  - 영단어 professionalism, few, hydroxyproline, simple 을 사전편찬 순서대로 정렬하라

#### 기수 정렬: 정렬의 원리

- 기수(radix) : 주어진 데이터를 구성하는 기본 요소(기호)
- 버킷(bucket) : 기수의 수에 해당하는 만큼의 버킷을 활용
- 6, 5, 2, 8 => [ , , 2, , , 5, 6, , 8, ] => 순서대로 꺼내 => 2, 5, 6, 8
- 단순히 넣고 빼기만 하면 됨. 정렬의 과정에서 데이터간 비교가 발생하지 않음

##### 기수 정렬 : LSD(List Significant Digit)

- 오름차순으로 정렬
- example
  - 1 3 4
  - 2 2 4
  - 2 3 2
  - 1 2 2
  1. 기준을 맨 오른쪽부터 실행
  - 버킷 0 ~ 4 중 맨 오른쪽 값들을 보고 해당 버킷에 넣기
  - 2 3 2
  - 1 2 2
  - 1 3 4
  - 2 2 4
  2. 가운데 를 기준으로 실행
  - 1 2 2
  - 2 2 4
  - 2 3 2
  - 1 3 4
  3. 맨 왼쪽을 기준으로 실행
  - 1 2 2
  - 1 3 4
  - 2 2 4
  - 2 3 2
