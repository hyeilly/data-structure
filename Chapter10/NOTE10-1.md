# 정렬

- 삽입, 삭제 탐색...
- 어떤 기준으로 **정렬**된 대상을 가지고 효율적으로 **탐색**

## 10-1. 단순한 정렬 알고리즘

- 구현은 쉽지만 성능은 만족스럽지 못함

### 버블정렬

#### 성능 평가

- 큰 차이가 나는 시간 복잡도를 주로 더 확인
- 성능 평가의 두 가지 기준
  - 비교의 횟수 : 두 데이터 간의 비교연산의 횟수
  - 이동의 횟수 : 위치의 변경을 위한 데이터의 이동 횟수
- 최악의 경우 - 비교의 횟수와 이동의 횟수는 일치 `O(n^2)`

```
for(i = 0; i < n - 1; i++)
{
  for(j = 0; j < (n - i) - 1; j++)
  {
    if(arr[j] > arr[j+1]){...}
  }
}
```

### 선택정렬

- 하나씩 선택해서 정렬 결과를 완성해 나감. 별도의 메모리 공간이 요구된다는 단점 있음
- 하나씩 비워 가면서 이동을 시킴

#### 성능 평가

- 최악의 경우와 최상의 경우 구분 없이 데이터 이동의 횟수는 동일
- 최악의 경우 - `O(n^2)`
- 데이터의 비교, 데이터의 이동

```
for(i = 0; i < n - 1; i++)
{
  maxIdx = i;
  for(j = i + 1; j < n; j++)
  {
    if(arr[i] < arr[maxIdx])
      maxIdx = j;
  }
  temp = arr[i];
  arr[i] = arr[maxIdx];
  arr[maxIdx] = temp;
}
```
