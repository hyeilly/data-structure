## 배열을 이용한 리스트의 구현

### 리스트의 이해

#### 리스트의 구분

- 순차 리스트 : 배열을 기반으로 구현된 리스트
- 연결 리스트 : 메모리의 동적 할당을 기반으로 구현된 리스트
- 이는 **구현 방법을 기준으로 한 구분**. 따라서 이 두 리스트의 ADT가 동일하다고 해서 문제가 되지 않음

#### 리스트의 특징

- 저장 형태 : 데이터를 나란히(하나의 열로) 저장
- 저장 특성 : 중복이 되는 데이터의 저장을 허용
- 이것이 리스트의 ADT를 정의하는데 있어서 고려해야 할 유일한 내용

### 리스트 자료구조의 ADT 1

- 배열 기반의 리스트이든 연결 기반의 리스트이든 ADT는 동일하게 적용
- `void ListInit(List * plist);` // 리스트의 초기화
  - C언어는 변수를 선언한다고 자동으로 호출되지않음 > C++,JAVA 생성자 통해 자동으로 초기화
  - 초기화할 리스트의 주소 값을 인자로 전달
  - 리스트 생성 후 제일 먼저 호출되어야 하는 함수
- `void LInsert(List * plist, LData data);` // 데이터 저장
  - 리스트에 데이터를 저장. 매개변수 data에 전달된 값을 저장
- `int LFirst(List _ plist, LData _ pdata);` // 저장된 데이터의 탐색 및 탐색 초기화
  - 첫 번째 데이터가 pdata가 가리키는 메모리에 저장
  - 데이터의 참조를 위한 초기화가 진행
  - 참조 성공 시 TRUE(1), 실패 시 FALSE(0) return
- LData는 저장 대상의 자료형을 결정할 수 있도록 typedef로 선언된 자료형의 이름

### 리스트 자료구조의 ADT 2

- `int LNext(List * plist, LData * pdata);` // 다음 데이터의 참조(반환)을 목적으로 호출
  - LFirst함수 호출 이후에 2번째 이후의 데이터를 얻을때 호출하는 함수
  - 참조된 데이터의 다음 데이터가 pdata가 가리키는 메모리에 저장됨
  - 순차적인 참조를 위해서 반복 호출이 가능
  - 참조를 새로 시작하려면 먼저 LFirst 함수를 호출
  - 참조 성공 시 TRUE(1), 실패 시 FALSE(0) return
  - LFirst 호출 > LNext 호출 > LNext 호출 ... (2, 3, 4 번째 데이터 ... )
  - 구분이 된 이유는?
    - 리스트 선언 후 데이터 10개 저장.> 프로그램 실행 마다 중간중간 데이터 조회
- `LData LRemove(List * plist);` // 바로 이전에 참조(반환)이 이뤄진 데이터의 삭제
  - LFirst 또는 LNext 함수의 마지막 반환 데이터를 삭제
  - 삭제된 데이터는 반환
  - 마지막 반환 데이터를 삭제하므로 연이은 반복 호출을 허용하지 않음
- `int LCount(List * plist);` // 현재 저장되어 있는 데이터의 수를 반환

  - 리스트에 저장되어 있는 데이터의 수를 반환

### 소스코드 설명

- 리스트 자료구조는 내부 구조와 상관없이 데이터들이 일련되게(나란히) 저장됨
  - 중복된 데이터의 저장을 허용
  - 데이터를 저장/참조하기 위한 자료구조(데이터 관리에 목적)
- [11, 22, 33]으로 나란히 저장됨.

#### 리스트의 데이터 참조 과정

- 데이터 참조 일련의 과정 : LFirst > LNext > LNext > LNext
- LFirst와 LNext 함수 구분을 짓는 이유
  - 모든 데이터를 한번만 참조하고 끝난다면 LNext만 존재해도 됨.
  - 하지만 데이터의 참조는 빈번히 일어남. 앞에서부터 참조해야하는 경우가 많으므로. 첫번째부터 참조를 진행하므로

#### 리스트의 데이터 삭제 방법

- LRemove 함수는 연이은 호출을 허용하지 않음
- 1, 2, 3데이터 가져옴... 데이터 확인 후 삭제 과정에서 처음부터 마지막까지 일련의 참조과정 동반
- 삭제할 정보 데이터를 전달하지 않고 list를 인자값으로 해서 LRemove 호출
  - 가장 최근에 참조한 데이터 삭제
- 자료에 저장된 거 끝까지 탐색 후 삭제

#### 배열 기반 리스트의 헤더파일 정의

- 리스트 ADT를 기반으로 선언된 함수들 은 배열 기반 리스트로 선언된 함수들의 내용을 제한할 필요 없음

#### 배열 기반 리스트의 초기화

- 실제로 초기화할 대상은 구조체 변수의 멤버. 따라서 초기화 함수의 구성은 구조체의 정의를 기반으로 함

#### 배열 기반 리스트의 삽입

#### 배열 기반 리스트의 조회

- LNext => 값의 반환은 매개변수를 통해. 함수의 반환은 성공여부를 알리기 위해 조회

#### 배열 기반 리스트의 삭제

- 삭제되는 데이터는 반환의 과정을 통해서 되돌려주기

- 삭제하는 데이터 뒤에 있는것들을 한칸씩 앞으로 이동
  - 빈공간을 채워서 유효한 데이터들로 차도록
- 삭제해야할 데이터의 인덱스 값은 curPosition

  - curPosition : 가장 최근에 참조가 이루어진 데이터의 인덱스 값을 저장하고 있음
  - curPosition 을 앞으로 한개 이동시키고

- 리스트 자료구조에 데이터 저장 - 동적할당 됨. (주소값만 저장되어있음)
  - 실제 구조체 변수는 힙(메모리 공간에 저장)
  - 메모리 공간의 삭제까지 리스트 자료구조의 책임으로 둘 것인지
  - 리스트 자료구조의 책임
    - 삭제까지 담당하지 않음
    - 리스트 자료구조에 임의의 주소값 잠시 저장 후 뺄 수 있음
    - 주소값이 동적할당된 경우도 있지만 아닐수도 있음
    - 주소값을 가지고 있는 것이지 가리키고 있는 대상과의 상관관계는 가지고있지 않음
  - 가지고 있는 주소값 삭제하라 하면 주소값을 전달
    - 내가 **동적할당 했으면** free함수 호출
    - 주소값 변수가 동적할당 안한것이라면 free함수 호출하지 않아도 됨
- 정리
  - 리스트 자료구조에 주소값을 저장한다
    - 주소 값을 실질적인 데이터로 평가함
    - => 가리키는 대상이 무엇인 지는 상관X

#### 배열 기반 리스트의 장점과 단점

##### 단점

- 배열의 길이가 초기에 결정되어야함. 변경 불가능
- 삭제의 과정에서 데이터의 이동(복사)가 매우 빈번히 일어남

##### 장점

- 데이터 참조가 쉬움. 인덱스 값 기준으로 어디든 한 번에 참조 가능
