## 배열을 이용한 리스트의 구현

### 리스트의 이해

#### 리스트의 구분

- 순차 리스트 : 배열을 기반으로 구현된 리스트
- 연결 리스트 : 메모리의 동적 할당을 기반으로 구현된 리스트
- 이는 **구현 방법을 기준으로 한 구분**. 따라서 이 두 리스트의 ADT가 동일하다고 해서 문제가 되지 않음

#### 리스트의 특징

- 저장 형태 : 데이터를 나란히(하나의 열로) 저장
- 저장 특성 : 중복이 되는 데이터의 저장을 허용
- 이것이 리스트의 ADT를 정의하는데 있어서 고려해야 할 유일한 내용

### 리스트 자료구조의 ADT 1

- 배열 기반의 리스트이든 연결 기반의 리스트이든 ADT는 동일하게 적용
- `void ListInit(List * plist);` // 리스트의 초기화
  - C언어는 변수를 선언한다고 자동으로 호출되지않음 > C++,JAVA 생성자 통해 자동으로 초기화
  - 초기화할 리스트의 주소 값을 인자로 전달
  - 리스트 생성 후 제일 먼저 호출되어야 하는 함수
- `void LInsert(List * plist, LData data);` // 데이터 저장
  - 리스트에 데이터를 저장. 매개변수 data에 전달된 값을 저장
- `int LFirst(List _ plist, LData _ pdata);` // 저장된 데이터의 탐색 및 탐색 초기화
  - 첫 번째 데이터가 pdata가 가리키는 메모리에 저장
  - 데이터의 참조를 위한 초기화가 진행
  - 참조 성공 시 TRUE(1), 실패 시 FALSE(0) return
- LData는 저장 대상의 자료형을 결정할 수 있도록 typedef로 선언된 자료형의 이름

### 리스트 자료구조의 ADT 2

- `int LNext(List * plist, LData * pdata);` // 다음 데이터의 참조(반환)을 목적으로 호출
  - LFirst함수 호출 이후에 2번째 이후의 데이터를 얻을때 호출하는 함수
  - 참조된 데이터의 다음 데이터가 pdata가 가리키는 메모리에 저장됨
  - 순차적인 참조를 위해서 반복 호출이 가능
  - 참조를 새로 시작하려면 먼저 LFirst 함수를 호출
  - 참조 성공 시 TRUE(1), 실패 시 FALSE(0) return
  - LFirst 호출 > LNext 호출 > LNext 호출 ... (2, 3, 4 번째 데이터 ... )
  - 구분이 된 이유는?
    - 리스트 선언 후 데이터 10개 저장.> 프로그램 실행 마다 중간중간 데이터 조회
- `LData LRemove(List * plist);` // 바로 이전에 참조(반환)이 이뤄진 데이터의 삭제
  - LFirst 또는 LNext 함수의 마지막 반환 데이터를 삭제
  - 삭제된 데이터는 반환
  - 마지막 반환 데이터를 삭제하므로 연이은 반복 호출을 허용하지 않음
- `int LCount(List * plist);` // 현재 저장되어 있는 데이터의 수를 반환
  - 리스트에 저장되어 있는 데이터의 수를 반환
