## 힙의 구현과 우선순위 큐의 완성

- 우선순위 큐를 구현하기 위해 밑바탕이 되는 것이 heap

### 힙에서의 데이터 저장과정

1. 자식 노드 데이터의 우선순위 <= 부모 노드 데이터의 우선순위
2. 새 데이터는 우선순위가 낮다는 가정하에 끝에 저장. 그리고 부모 노드와 비교를 진행
3. 부모 노드와 비교 및 자리 바꿈
4. 제자리 찾기

### 힙에서의 데이터 삭제과정

1. 루트 노드에 저장된 것 삭제(=꺼냄)
2. 마지막 노드를 루트 노드로 이동
3. 자식 노드와 비교 후 이동
4. 자식 노드와 비교 후 자리 확정

## 삽입과 삭제 과정에서 보인 성능의 평가

- 내려가면서 자리가 결정되는 구조. 자리를 찾는 것에 있어서 비교연산 후 자리를 잡게 됨

### 배열 기반 우선순위 큐의 시간 복잡도

- 배열 기반 데이터 삽입의 시간 복잡도 `O(n)`
- 배열 기반 데이터 삭제의 시간 복잡도 `O(1)`

### 연결 리스트 기반 우선순위 큐의 시간 복잡도

- 연결 리스트 기반 데이터 삽입의 시간 복잡도 `O(n)`
- 연결 리스트 기반 데이터 삭제의 시간 복잡도 `O(1)`

### 힙 기반 우선순위 큐의 시간 복잡도

- 힙 기반 데이터 삽입의 시간 복잡도 `O(log2n)`
- 힙 기반 데이터 삭제의 시간 복잡도 `O(log2n)`

## 배열을 기반으로 힙을 구현하는 데 필요한 지식들

- 연결리스트를 기반으로 힘을 구현하면, 새로운 노드를 힙의 '마지막 위치'에 추가하는 것이 쉽지 않음

### 배열 기반에서 인덱스 값 구하기

- 왼쪽 자식 노드의 인덱스 값 => 부모 노드의 인덱스 값 \* 2
- 오른쪽 자식 노드의 인덱스 값 => 부모 노드의 인덱스 값 \* 2 + 1
- 부모 노드의 인덱스 값 => 자식 노드의 인덱스 값 / 2

## 원리 이해 중심의 힙 구현

- 힙은 완전 이진 트리
- 힙의 구현은 배열을 기반으로 하며, 인덱스가 0인 요소는 비워둠
- **힙에 저장된 노드의 개수와 마지막 노드의 고유번호는 일치**
- 노드의 고유번호가 노드가 저장되는 배열의 인덱스 값이 됨
- 우선순위를 나타내는 정수 값이 작을수록 높은 우선순위를 나타낸다고 가정

### 힙에서의 삭제

1. 루트노드 삭제
2. 마지막 노드를 루트로 가져다 놓고

- 왼쪽 오른쪽 노드를 2개다 비교하는 것이 아닌
- 둘 중 우선순위가 높은 자식노드와의 우선순위를 비교

3. 부모,자식 간 우선순위를 비교하여 자리를 찾아감

### 우선순위큐에서

- 프로그래머 or 프로그램 사용자가 데이터의 우선순위를 직접 결정해야한다는 사실이 매우 안좋음..
- 일반적으로는 데이터를 근거로해서 우선순위가 결정됨
