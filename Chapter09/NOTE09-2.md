## 힙의 구현과 우선순위 큐의 완성

- 우선순위 큐를 구현하기 위해 밑바탕이 되는 것이 heap

### 힙에서의 데이터 저장과정

1. 자식 노드 데이터의 우선순위 <= 부모 노드 데이터의 우선순위
2. 새 데이터는 우선순위가 낮다는 가정하에 끝에 저장. 그리고 부모 노드와 비교를 진행
3. 부모 노드와 비교 및 자리 바꿈
4. 제자리 찾기

### 힙에서의 데이터 삭제과정

1. 루트 노드에 저장된 것 삭제(=꺼냄)
2. 마지막 노드를 루트 노드로 이동
3. 자식 노드와 비교 후 이동
4. 자식 노드와 비교 후 자리 확정

## 삽입과 삭제 과정에서 보인 성능의 평가

- 내려가면서 자리가 결정되는 구조. 자리를 찾는 것에 있어서 비교연산 후 자리를 잡게 됨

### 배열 기반 우선순위 큐의 시간 복잡도

- 배열 기반 데이터 삽입의 시간 복잡도 `O(n)`
- 배열 기반 데이터 삭제의 시간 복잡도 `O(1)`

### 연결 리스트 기반 우선순위 큐의 시간 복잡도

- 연결 리스트 기반 데이터 삽입의 시간 복잡도 `O(n)`
- 연결 리스트 기반 데이터 삭제의 시간 복잡도 `O(1)`

### 힙 기반 우선순위 큐의 시간 복잡도

- 힙 기반 데이터 삽입의 시간 복잡도 `O(log2n)`
- 힙 기반 데이터 삭제의 시간 복잡도 `O(log2n)`

## 배열을 기반으로 힙을 구현하는 데 필요한 지식들

- 연결리스트를 기반으로 힘을 구현하면, 새로운 노드를 힙의 '마지막 위치'에 추가하는 것이 쉽지 않음

### 배열 기반에서 인덱스 값 구하기

- 왼쪽 자식 노드의 인덱스 값 => 부모 노드의 인덱스 값 \* 2
- 오른쪽 자식 노드의 인덱스 값 => 부모 노드의 인덱스 값 \* 2 + 1
- 부모 노드의 인덱스 값 => 자식 노드의 인덱스 값 / 2

## 원리 이해 중심의 힙 구현

- 힙은 완전 이진 트리
- 힙의 구현은 배열을 기반으로 하며, 인덱스가 0인 요소는 비워둠
- **힙에 저장된 노드의 개수와 마지막 노드의 고유번호는 일치**
- 노드의 고유번호가 노드가 저장되는 배열의 인덱스 값이 됨
- 우선순위를 나타내는 정수 값이 작을수록 높은 우선순위를 나타낸다고 가정

### 힙에서의 삭제

1. 루트노드 삭제
2. 마지막 노드를 루트로 가져다 놓고

- 왼쪽 오른쪽 노드를 2개다 비교하는 것이 아닌
- 둘 중 우선순위가 높은 자식노드와의 우선순위를 비교

3. 부모,자식 간 우선순위를 비교하여 자리를 찾아감

### 우선순위큐에서

- 프로그래머 or 프로그램 사용자가 데이터의 우선순위를 직접 결정해야한다는 사실이 매우 안좋음..
- 일반적으로는 데이터를 근거로해서 우선순위가 결정됨

## 구조체 변경

```
typedef struct _heapElem
{
  Priority pr;
  HData data;
} HeapElem;

typedef struct _heap
{
  int numOfData;
  HeapElem heapArr[HEAP_LEN];
} Heap;
```

- Heap에 저장하는 데이터의 기본 단위 HeapElem도 구조체의 자료형
  - 실제로 저장해야하는 data, 데이터의 우선순위 pr을 하나로 묶기 위함
  - 불합리. 보편적으로 사용하기엔 불편
  - 일반적으로는 우선순위를 판단하는 기준이 데이터 이므로
  - 기준을 결정하면 데이터만 가지고 우선순위를 비교하는 것이 합리적
- data가 있음에도 pr 우선순위가 다름
  - ex) 같은 데이터 5가 2개 들어왔을 때 1개는 우선순위1 다른 한개는 우선순위2 일수 있음
- 우선순위 정보를 별도로 유지하지 않는 것이 바랍직함
- 힙 구현 후 데이터 우선순위를 결정하는 기준을 함수로 등록.
  - 함수 호출 결과로 우선순위 판단
- `typedef int PriorityComp(HData d1, HData d2);` 함수포인터 선언
  - \* 을 안붙임
  - PriorityComp를 선언할 때 반드시 \* 을 붙여라
  - 매개변수로 쓰는 경우 예외. \*을 붙이든 아니든 상관없음
  - 만약 `typedef int (*PriorityComp)(HData d1, HData d2)` 으로 붙였다면 \*을 빼서 쓰겠다

```
typedef struct _heap
{
  PriorityComp * comp; // 우선순위 판단하는 함수의 주소값을 저장
  int numOfData;
  HData heapArr[HEAP_LEN];
} Heap;
```

- 구조체 변경에 따른 초기화 함수의 변경

```
void HeapInit(Heap * ph, PriorityComp pc)
{
  ph->numOfData = 0;
  ph->comp = pc;
}
```

## PriorityComp 형 함수의 정의 기준

- 첫 번째 인자의 우선순위가 높다면 0보다 큰 값 반환
- 두 번째 인자의 우선순위가 높다면 0보다 작은 값 반환
- 첫 번째, 두 번째 인자의 우선순위가 동일하다면 0이 반환

`void HInsert(Heap * ph, HData data, Priority pr);`

- 우선순위 정보를 별도로 받지 않아 `void HInsert(Heap * ph, HData data);`

#### 힙의 함수를 사실상 우선순의 큐의 내용으로 구현

- HInsert 함수는 PEnqueue() 기능
- HDelete 함수는 PDequeue() 기능
