## 큐의 배열 기반 구현

### 큐의 구현 논리

- 스택은 바닥이 정해져 있었음(기준점이 명확)
- 큐는 논리적으로 입구와 출구가 있음. ex) 입구는 인덱스 0, 출구는 인덱스 3
- 입구와 출구가 유동적으로 바뀜
- enqueue
  - 큐의 꼬리를 의미하는 R을 한 칸 이동시키고 새 데이터를 저장(새로운 데이터를 가리키는 것이 끝임)
  - Example
    - enqueue A : A(F/R)
    - enqueue B : A(F) B(R)
    - enqueue C : A(F) B C(R)
- dequeue
  - 큐의 머리를 의미하는 F가 가리키는 데이터를 반환하고 F를 한칸 이동시킴
  - Example
    - A(F) B C(R)
    - dequeue B(F) C(R)
    - dequeue C(F/R)

### 가장 기본적인 배열 기반 큐의 문제점

- example
  - A(F) B C(R)
  - dequeue : B(F) C(R)
  - dequeue : C(F/R)
  - enqueue D : C(F) D(R)
- 분명히 배열은 비어있지만 R을 오른쪽으로 한칸 이동시킬 수 없어서 더이상 데이터 추가 불가능
- 데이터를 더 추가하기 위해서는 R을 인덱스가 0인 위치로 이동시켜야함
- 이러한 방식으로 문제를 해결한 것이 **'원형 큐'**

## 원형 큐의 소개

- A(F) B C(R)
- R과 F가 배열의 끝에 도달하면 다시 앞으로 돌아감
- 배열의 머리와 끝을 연결한 구조를 원의 형태로 바라봄

### 원형 큐의 단순한 연산

- 단순 배열 큐와 마찬가지로 R이 이동한 다음에 데이터 저장
- 단순 배열 큐와 마찬가지로 F가 가리키는 데이터 반환 후 F 이동

### 문제점

- 완전히 비어있거나 완전히 채워져 있는 상태를 확인할 수 있는 방법은 F와 R의 관계를 판한다는 것을 먼저 구현하기
- Full => A(F) B C D(R)
- Empty => F R
- R의 위치를 한칸 이동하면 F와 같은 위치가 됨
- 완전히 채워졌을 때의 F, R의 관계와 완전히 비워졌을 때의 F, R의 관계가 같음

### 해결

- 데이터가 하나 존재하는 경우 F와 R이 같은 위치를 가리켰는데 초기화 직후 이 상태가 되게 함
  - 새로운 데이터 저장 시 R을 먼저 이동 후 저장해야함
  - 메모리 공간 하나 손실했지만. 꽉 찬 상태로 약속하면 R과 F가 같으면 empty, R에서 한칸 오른쪽으로 가서 F와 같아지면 FULL의 상태가 됨
- 큐의 연산에 의해서 F(front)와 R(rear)이 이동할 때 이동해야 할 위치를 알려주는 함수. 원형 큐를 완성하게 하는 실질적인 함수
