# 탐색2

## 균형 잡힌 이진 탐색 트리: AVL 트리의 이해

### 이진 탐색 트리의 문제점과 AVL 트리

- ex) 1부터 5까지 순서대로 저장이 된 경우.
  - 1은 루트노드. 2, 3, 4, 5 아래로 계속해서 오른쪽 노드에 추가
- 이진 탐색 트리의 탐색 연산은 O(log2n)의 시간 복잡도를 보임
- 그러나 균형이 맞지 않을 수록 O(n)에 가까운 시간 복잡도를 보임 (선형자료구조가 되버림..)
- 이진 탐색 트리의 균형 문제를 해결한 트리
  - AVL 트리
  - 2-3-4 트리
  - Red-Black 트리
- ex) 3이 제일 번저 저장된 경우. => 약간의 순서 변화로 균형 잡힘

### 자동으로 균형 잡는 AVL 트리와 균형 인수

- 균형이 무너진 경우를 판단하기 위해 균형 인수 계산해서 각 노드에 반영
  - 불필요하게 높이가 높아짐
- `균형 인수` = 왼쪽 서브 트리의 높이 - 오른쪽 서브 트리의 높이
  - 균형 인수의 절댓값이 2 이상인 경우 리 밸런싱 진행
  - AVL 트리는 균형 인수를 기준으로 트리의 균형을 잡기 위한 재조정인 진행 시기를 결정

### 리밸런싱이 필요한 첫 번째 상태와 LL회전

- LL 상태 / RR 상태 / LR 상태 / RL 상태

  - 각각 상태로 균형잡는 방법 -> 하나로 묶어서 이진 탐색 트리에 넣으면 균형 잡힌 이진 트리 오나정

- ex) 5의 왼쪽 자식노드 3, 3의 왼쪽 자식노드 1
- LL 상태
  - 5가 저장된 노드의 왼쪽(Left)에 3이 저장된 자식 노드가 하나 존재하고, 그 자식 노드의 왼쪽(Left)에 1이 저장된 자식 노드가 또 하나 존재
  - 이런 LL상태를 균형 잡기 위해서 LL 회전을 진행

### LL상태를 균형 잡기 위한 LL회전

- LL 회전 `ChangeRightSubTree(currentNode, parentNode);`
- 서브트리가 있을 수 있고, 없을 수도 있음. => 단순한 예시로 일반화한 코드 작성 필요
  - `ChangeLeftSubTree(parentNode, GetRightSubTree(currentNode));`
  - `ChangeRightSubTree(currentNode, parentNode);`
- RR 상태와 RR 회전
  - `ChangeRightSubTree(parentNode, GetLeftSubTree(currentNode));`
  - `ChangeLeftSubTree(currentNode, parentNode);`

### LR 상태

- LL상태 그리고 RR상태와 같이 한 번의 회전으로 균형을 잡을 수 없음
  - ex) 간단한 LR 상태
    - 5의 왼쪽 노드 1, 1의 오른쪽 노드 3
    - 1. LL 상태가 되도록 바꾸기 위해 RR 회전 적용
- RR 회전
  - 일반적인 RR 회전
    - 5의 오른쪽 노드 7, 7의 오른쪽 노드 9
  - 단말 노드가 NULL인 경우에도 RR 회전 자능
    - 5의 오른쪽 노드 7, 7의 오른쪽 노드 NULL
  - 부모 자식의 관계가 바뀌는 부수적인 효과
    - 5의 오른쪽 노드 7 => RR 회전하여 7이 부모노드, 5가 자식노드
- 따라서 LR 상태는 한 번의 회전으로 균형이 잡히는 LL상태 또는 RR상태가 되도록 하는 것이 우선
- LR 상태는 RR 회전을 통해서 (RR 회전의 부수적인 효과를 이용해서) LL 상태가 되게 할 수 있음

- `LR 상태 > RR 회전 > LL 회전 `

### RL 상태와 RL 회전

- LR 상태 LR 회전, 그리고 RL 상태 RL 회전은 방향에서만 차이를 보임
- `RL 상태 > LL 회전 > RR 회전 `
